#### 1 **给定一个未知长度的整数流，如何随机选取一个数？**

> 如果整数流在第一个数后结束，则我们必定会选第一个数作为随机数。
>
> 如果整数流在第二个数后结束，我们选第二个数的概率为1/2。我们以1/2的概率用第2个数替换前面选的随机数，得到满足条件的新随机数。
>
> ....
>
> 如果整数流在第n个数后结束，我们选第n个数的概率为1/n。我们以1/n的概率用第n个数替换前面选的随机数，得到满足条件的新随机数。
>
> ....
>
> 利用这种方法，我们只需保存一个随机数，和迄今整数流的长度即可。所以可以处理任意长的整数流。

#### **2 求一个论坛的在线人数，假设有一个论坛，其注册ID有两亿个，每个ID从登陆到退出会向一个日志文件中记下登陆时间和退出时间，要求写一个算法统计一天中论坛的用户在线分布，取样粒度为秒。**

> 一天总共有 3600*24 = 86400秒。
>
> 定义一个长度为86400的整数数组int delta[86400]，每个整数对应这一秒的人数变化值，可能为正也可能为负。开始时将数组元素都初始化为0。
>
> 然后依次读入每个用户的登录时间和退出时间，将与登录时间对应的整数值加1，将与退出时间对应的整数值减1。
>
> 这样处理一遍后数组中存储了每秒中的人数变化情况。
>
> 定义另外一个长度为86400的整数数组int online_num[86400]，每个整数对应这一秒的论坛在线人数。
>
> 假设一天开始时论坛在线人数为0，则第1秒的人数online_num[0] = delta[0]。第n+1秒的人数online_num[n] = online_num[n-1] + delta[n]。
>
> 这样我们就获得了一天中任意时间的在线人数。

#### **3 在一个文件中有** **10G** **个整数，乱序排列，要求找出中位数。内存限制为** 2G

> 不妨假设10G个整数是64bit的。
>
> 2G内存可以存放256M个64bit整数。
>
> 我们可以将64bit的整数空间平均分成256M个取值范围，用2G的内存对每个取值范围内出现整数个数进行统计。这样遍历一边10G整数后，我们便知道中数在那个范围内出现，以及这个范围内总共出现了多少个整数。
>
> 如果中数所在范围出现的整数比较少，我们就可以对这个范围内的整数进行排序，找到中数。如果这个范围内出现的整数比较多，我们还可以采用同样的方法将此范围再次分成多个更小的范围（256M=2^28，所以最多需要3次就可以将此范围缩小到1，也就找到了中数）。

#### 4 **有**1000瓶水，其中有一瓶有毒，小白鼠只要尝一点带毒的水24小时后就会死亡，至少要多少只小白鼠才能在24小时时鉴别出那瓶水有毒？



#### 5 1024!末尾有多少个0

> 末尾0的个数取决于乘法中因子2和5的个数。显然乘法中因子2的个数大于5的个数，所以我们只需统计因子5的个数。
>
> 是5的倍数的数有： 1024 / 5 = 204个
>
> 是25的倍数的数有：1024 / 25 = 40个
>
> 是125的倍数的数有：1024 / 125 = 8个
>
> 是625的倍数的数有：1024 / 625 = 1个
>
> 所以1024! 中总共有204+40+8+1=253个因子5。
>
> 也就是说1024! 末尾有253个0。

#### 6 给定能随机生成整数1到5的函数，写出能随机生成整数1到7的函数

> 只要我们可以从 n 个数中随机选出 1 到 n 个数，反复进行这种运算，直到剩下最后一个数即可。
>
> 我们可以调用 n 次给定函数，生成 n 个 1 到 5 之间的随机数，选取最大数所在位置即可满足以上要求。
>
> 例如
>
> 初始的 7 个数 [1,2,3,4,5,6,7].
>
> 7 个 1 到 5 的随机数 [5, 3,1,4,2,5,5]
>
> 那么我们保留下[1,6,7],
>
> 3 个1 到 5 的随机数[2,4,1]
>
> 那么我们保留下[6]
>
> 6 就是我们这次生成的随机数。

#### 7 **洗牌算法**

> 给出洗牌的一个算法，并将洗好的牌存储在一个整形数组里。
>
> 假设数组Card[0 - 53]中的54个数对应54张牌，从第一张牌（i = 0）开始直到倒数第二张牌（i = 52），每次生成一个[ i, 53]之间的数r，将Card[i]和Card[r]中的数互换。

