# 软/硬中断

- 硬中断：指由硬件设备触发的一种中断机制，主要用于通知操作系统需要立即处理某个事件。硬中断的目的是确保计算机对外部设备的请求作出快速响应，例如键盘输入、鼠标点击、网络数据包到达等。
- 软中断：一种由软件触发的中断机制，用于在内核态处理某些无需立即执行的任务，由系统内核线程执行

示例：

> **硬中断与软中断的配合步骤**
>
> ​	1.	**硬中断触发**：
>
> ​	•	网卡收到网络数据包后，发送一个中断信号给 CPU。
>
> ​	•	CPU 响应中断信号，暂停当前任务，跳转到网卡的硬中断处理程序。
>
> ​	2.	**硬中断处理程序**：
>
> ​	•	硬中断处理程序快速执行以下操作：
>
> ​	•	**确认中断**：检查网卡状态，确定中断来源（如数据包到达）。
>
> ​	•	**数据缓存**：从网卡缓冲区中将数据包复制到内存中的一个环形缓冲区（ring buffer）。
>
> ​	•	**触发软中断**：标记一个软中断请求（例如在 Linux 中触发 NET_RX_SOFTIRQ）。
>
> ​	•	硬中断处理完成后，迅速返回，以避免长时间占用 CPU。
>
> ​	3.	**软中断处理**：
>
> ​	•	系统在稍后的时间段（如退出硬中断上下文、任务调度时）检查是否有软中断需要处理。
>
> ​	•	如果有，调度软中断处理程序执行以下任务：
>
> ​	•	**解析数据包**：从环形缓冲区中读取数据包。
>
> ​	•	**协议栈处理**：将数据包传递给操作系统的网络协议栈，进行 IP、TCP 等协议的解析。
>
> ​	•	**通知用户程序**：将解析后的数据传递给用户空间的应用程序。



# 内存管理

## 分段/分页

**分段** 和 **分页** 是计算机内存管理中的两种重要机制，用于将进程的地址空间映射到物理内存中。它们有不同的特点和用途，以下是详细的解释：

---

### 1. 分段 (Segmentation)

![image-20241219150908385](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20241219150908385.png)

#### 概念
分段是一种按照逻辑功能划分内存空间的技术。进程的地址空间被分成若干逻辑片段，每个片段对应特定的功能，比如代码段、数据段、堆栈段等。每个段独立管理，可以动态调整大小。

#### 特点
1. **逻辑划分**：基于程序的逻辑结构（如代码段、数据段）进行划分。  
2. **段表**：每个段都有一个段描述符，段描述符包含段基地址和段长度，段表用于记录这些信息。  
3. **地址结构**：逻辑地址由两个部分组成：  
   - **段号（Segment Number）**：指明访问的是哪个段。  
   - **段内偏移（Offset）**：指定段内的具体地址。  
4. **内存分配灵活**：不同段可以分配在物理内存的不同位置，且大小可以动态调整。

#### 优点
- 容易满足程序的逻辑需求，程序更易开发和维护。
- 支持不同段的权限管理（如代码段只读、数据段可读写）。

#### 缺点
- 内存碎片问题：由于段大小不固定，容易出现外部碎片。

---

### 2. 分页 (Paging)

![image-20241219151031830](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20241219151031830.png)

<u>页表是存储在内存里的，**内存管理单元** （*MMU*）就做将虚拟内存地址转换成物理地址的工作。</u>

#### 概念

分页是将内存划分为固定大小的块（称为页框或帧），同时将进程的地址空间划分为等大小的页。分页的目的是实现更高效的内存利用。

#### 特点
1. **固定大小**：页和页框的大小固定（通常是 4KB 或更大）。  
2. **页表**：记录每个逻辑页与物理页框的映射关系。  
3. **地址结构**：逻辑地址分为两部分：  
   - **页号（Page Number）**：指明逻辑地址属于哪个页。  
   - **页内偏移（Offset）**：指明页内的具体地址。  
4. **连续性不要求**：逻辑页在物理内存中可以不连续，解决了外部碎片问题。

#### 优点
- 有效减少外部碎片问题。
- 更容易实现虚拟内存。

#### 缺点
- 页表可能占用较多内存，尤其是进程地址空间很大时。
- 存取时间增加：每次内存访问需要查页表，可能引入额外的延迟。

---

### 3. 分段 vs 分页

| **特性**       | **分段 (Segmentation)**          | **分页 (Paging)**                  |
| -------------- | -------------------------------- | ---------------------------------- |
| **内存划分**   | 按逻辑划分（代码段、数据段等）   | 按固定大小划分（页和页框）         |
| **碎片问题**   | 易出现外部碎片                   | 主要有内部碎片                     |
| **地址结构**   | 段号 + 段内偏移                  | 页号 + 页内偏移                    |
| **连续性要求** | 段内地址必须连续                 | 页在物理内存中不要求连续           |
| **实现复杂度** | 较高，需管理段表                 | 较低，需管理页表                   |
| **适用场景**   | 强调逻辑结构，适用于复杂应用程序 | 强调内存利用率，适用于现代操作系统 |

---

### 4. 分段和分页的结合

现代操作系统（如 Linux、Windows）通常结合分段和分页：  
- **分段** 提供逻辑上的内存划分（如不同的代码段和数据段）。  
- **分页** 解决内存分配





## 内存满了会发生什么？ —— 缺页中断处理过程

<img src="https://cdn.xiaolincoding.com//mysql/other/2f61b0822b3c4a359f99770231981b07.png" alt="img" style="zoom:50%;" />

当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生**缺页中断**，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。

缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。

如果没有空闲的物理内存，那么内核就会开始进行**回收内存**的工作，回收的方式主要是两种：直接内存回收和后台内存回收。

- **后台内存回收**（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——**触发 OOM （Out of Memory）机制**。

OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。



### 哪些内存会被回收？

主要有两类内存可以被回收，而且它们的回收方式也不同。

- **文件页**（File-backed Page）：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页。大部分文件页，都可以直接释放内存，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以，**回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存**。
- **匿名页**（Anonymous Page）：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们**回收的方式是通过 Linux 的 Swap 机制**，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。

文件页和匿名页的回收都是基于 LRU 算法，也就是优先回收不常访问的内存。



## 在4G物理内存机器上申请8G空间

![image-20241219150104704](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20241219150104704.png)

- 在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。
- 在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：
  - 如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；
  - 如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；





## 预读失效/缓存污染

> 前提：
>
> 1. 磁盘读取效率远小于内存读取，在内存中有一个缓冲空间==（ Linux 的 Page Cache 和 MySQL 的 Buffer Pool 缓存）==用于缓存磁盘数据，通常使用LRU算法进行页面淘汰机制
>
> 2. 由于操作系统空间局部性原理（靠近当前被访问数据的数据，在未来很大概率会被访问到），Linux 操作系统为基于 Page Cache 的读缓存机制提供**预读机制**，比如当读取4KB时，会加载相邻的16KB数据到buffer中
>
>    ![img](https://cdn.xiaolincoding.com//mysql/other/ae8252378169c8c14b8b9907983f7d8b.png)

传统的 LRU 算法法无法避免下面这两个问题：

- 预读失效导致缓存命中率下降；
- 缓存污染导致缓存命中率下降；



### 预读失效

> [!NOTE]
>
> 什么是：**不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率**

为了避免「预读失效」造成的影响，Linux 和 MySQL 对传统的 LRU 链表做了改进：

- Linux 操作系统实现两个了 LRU 链表：**活跃 LRU 链表（active list）和非活跃 LRU 链表（inactive list）**。
- MySQL Innodb 存储引擎是在一个 LRU 链表上划分来 2 个区域：**young 区域 和 old 区域**。

但是如果还是使用「只要数据被访问一次，就将数据加入到活跃 LRU 链表头部（或者 young 区域）」这种方式的话，那么**还存在缓存污染的问题**。



### 缓存污染

> [!NOTE]
>
> 什么是：当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到「活跃 LRU 链表」里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，**如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了**。

为了避免「缓存污染」造成的影响，Linux 操作系统和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛：

- Linux 操作系统：在内存页被访问**第二次**的时候，才将页从 inactive list 升级到 active list 里。

- MySQL Innodb：在内存页被访问

  第二次

  的时候，并不会马上将该页从 old 区域升级到 young 区域，因为还要进行

  停留在 old 区域的时间判断：

  - 如果第二次的访问时间与第一次访问的时间**在 1 秒内**（默认值），那么该页就**不会**被从 old 区域升级到 young 区域；
  - 如果第二次的访问时间与第一次访问的时间**超过 1 秒**，那么该页就**会**从 old 区域升级到 young 区域；

通过提高了进入 active list （或者 young 区域）的门槛后，就很好了避免缓存污染带来的影响。





# 进程&线程

## 上下文切换

- 上下文切换场景：1️⃣时间片耗尽 2️⃣所需系统资源不足 3️⃣主动挂起sleep 4️⃣有更高优先级进程运行 5️⃣硬件中断
- 上下文切换了什么：
  - 进程：CPU寄存器、pc、页表、堆栈、其他与进程相关的资源（如文件描述符表）。
  - 线程：CPU寄存器、pc、栈指针

## 进程、线程、协程区别

进程：操作系统分配资源的基本单位。

线程：操作系统调度的基本单位。

协程：一种轻量级的用户态线程。

- 区别：1️⃣ 调度方式、2️⃣ 切换开销、3️⃣资源独立性、4️⃣通信开销、5️⃣ 内存占用

## 调度算法

- **先来先服务**（First Come First Serve, FCFS）
- **最短作业优先** （Shortest Job First，SJF）
- **高响应比优先** （Highest Response Ratio Next, HRRN）：（等待时间 + 运行时间）/ 运行时间
- **时间片轮转**（Round Robin, RR）
- **最高优先级调度算法**（Highest Priority First，HPF）：静态优先级/动态优先级、 抢占式/非抢占式
- **多级反馈队列调度算法**（Multilevel Feedback Queue）：多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列

## 进程间通信

1️⃣ 管道（匿名/命名） 2️⃣ 消息队列 3️⃣ 信号量 4️⃣ 信号  5️⃣ 共享内存 6️⃣ socket

## 经典同步问题

### 哲学家就餐问题

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/23-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E6%A8%A1%E5%9E%8B.jpg" alt="哲学家就餐的问题" style="zoom:50%;" />



- 方法一：通过信号量表示叉子是否可用(方法1、2、3)，每个人依次拿左右手的叉子，最后会导致<u>死锁</u>
- 方法二：在方法一的基础上对整个操作加锁，虽然避免了死锁但是<u>一次只能有一个哲学家就餐</u>
- 方法三：破坏循环等待的条件，根据位置的奇偶，依次拿起左右手叉子的顺序不同
- 方法四：通过信号量表示哲学家是否就餐，使用三个状态表示哲学家当前行为（think、eat、hungry），只有当附近哲学家均未就餐并且自己为hungry状态时才就餐P(s[i]) （信号量初始值为0，若没有叉子会阻塞），就餐完成之后执行P(s[i-1])、P(s[i+1])

### 读者-写者问题





# 页面置换/磁盘调度算法

## 页面置换算法

### 缺页异常处理流程

![缺页中断的处理流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png)

### 常见的页面置换算法

- **醉解页面置换算法**：置换掉未来最长时间不访问的页面
- **先进先出**
- **最近最久未使用（LRU）**：<u>导致预读失效和缓存污染问题</u>
- **时钟页面置换算法**：把页面放在一个环形链表中，每个节点设置一个<u>访问位</u>，当被访问时置1，发生缺页中断时，遍历节点，如果访问位为1，则置0； 若访问位为0，则将其淘汰
- **最不常用算法**：将访问次数最少的淘汰（考虑到小的时间范围内，访问次数高的问题，可以定期减少访问次数，如当发生时间中断时，访问次数除2）



## 磁盘调度算法

### 机械磁盘构造

![image-20250104131055960](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20250104131055960.png)

识别：盘片、磁头、磁道、扇区、柱面

### 调度算法

- **先来先服务**
- **最短寻道时间优先**：将请求访问位置与当前磁头位置计算差值，从小到大排序（<u>可能产生饥饿现象</u>）
- **扫描算法**：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的**最后的磁道**，才调换方向，这就是扫描（Scan）算法。（<u>中间部分相比其他部分响应的频率会比较多</u>，也就是说每个磁道的响应频率存在差异）
- **循环扫描算法**：为解决每个磁道响应频率不一致问题，循环扫描钟<u>磁道只响应一个方向上的请求</u>
- **LOOK与C-LOOK算法**：前面说到的扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才开始调换方向。那这其实是可以优化的，优化的思路就是**磁头在移动到「最远的请求」位置，然后立即反向移动。**
