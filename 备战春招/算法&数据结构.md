# 排序





# 红黑树/AVL树





# 如何解决哈希冲突

**1️⃣ Redis 中的哈希冲突解决方案：**

Redis 内部使用哈希表来存储键值对，解决哈希冲突的方法有：

​	•	**链表法（链式哈希）**：每个桶(bucket)中存储一条链表，若多个键值对的哈希值相同，它们就被存储在同一条链表中。Redis 在哈希表桶中使用链表来存储冲突的元素。

​	•	**再哈希（rehash）**：当哈希表达到一定负载因子时，Redis 会自动扩展哈希表，并且重新计算每个键的哈希值，将其放入新的哈希表中，这样可以避免大量冲突。

Redis 本身使用 **开放定址法**（open addressing）来避免链表过长，常见的实现策略是**线性探测**。



**2️⃣ C++ 中的哈希冲突解决方案：**

在 C++ 中，标准库中的 std::unordered_map 和 std::unordered_set 也基于哈希表实现。解决哈希冲突的方式有：

​	•	**链表法（链式哈希）**：每个桶是一个链表或其他容器类型（比如 std::list），冲突的元素会被存储在同一个桶中，形成链表。

​	•	**开放定址法（Open Addressing）**：通过探测（例如线性探测、二次探测、双重哈希）来解决冲突。如果一个桶已经被占用，C++ 库会在哈希表中按照一定规则查找下一个空桶，直到找到空位置为止。

std::unordered_map 默认采用链式哈希法，不过也支持根据需求进行定制，比如可以自定义哈希函数。



**3️⃣ Golang 中的哈希冲突解决方案：**

Go 语言的 map 类型也使用哈希表实现。解决哈希冲突的策略主要有：

​	•	**链表法（链式哈希）**：Go 内部会使用链表来存储哈希冲突的键值对。当两个键值对哈希值相同时，它们会被存储在同一个桶中，并通过链表链接。

​	•	**探测法**：Go 语言在某些情况下也会使用开放定址法（即在冲突时使用线性探测）。

Go 的 map 实现中还考虑了负载因子的动态调整和哈希表的扩展，因此它能够有效地处理哈希冲突，并根据实际需要调整性能。



**总结：**

​	•	**Redis**：采用链式哈希和再哈希机制，结合开放定址法优化冲突。

​	•	**C++**：通过链式哈希和开放定址法来解决冲突，标准库提供了内置的哈希表实现。

​	•	**Golang**：内部使用链式哈希法，也有一定的开放定址处理，结合负载因子优化性能。
