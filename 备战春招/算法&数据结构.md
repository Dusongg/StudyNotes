# 排序





# 红黑树/AVL树





# 如何解决哈希冲突

**1️⃣ Redis 中的哈希冲突解决方案：**

Redis 内部使用哈希表来存储键值对，解决哈希冲突的方法有：

​	•	**链表法（链式哈希）**：每个桶(bucket)中存储一条链表，若多个键值对的哈希值相同，它们就被存储在同一条链表中。Redis 在哈希表桶中使用链表来存储冲突的元素。

​	•	**再哈希（rehash）**：当哈希表达到一定负载因子时，Redis 会自动扩展哈希表，并且重新计算每个键的哈希值，将其放入新的哈希表中，这样可以避免大量冲突。

Redis 本身使用 **开放定址法**（open addressing）来避免链表过长，常见的实现策略是**线性探测**。



**2️⃣ C++ 中的哈希冲突解决方案：**

在 C++ 中，标准库中的 std::unordered_map 和 std::unordered_set 也基于哈希表实现。解决哈希冲突的方式有：

​	•	**链表法（链式哈希）**：每个桶是一个链表或其他容器类型（比如 std::list），冲突的元素会被存储在同一个桶中，形成链表。

​	•	**开放定址法（Open Addressing）**：通过探测（例如线性探测、二次探测、双重哈希）来解决冲突。如果一个桶已经被占用，C++ 库会在哈希表中按照一定规则查找下一个空桶，直到找到空位置为止。

std::unordered_map 默认采用链式哈希法，不过也支持根据需求进行定制，比如可以自定义哈希函数。



**3️⃣ Golang 中的哈希冲突解决方案：**

Go 语言的 map 类型也使用哈希表实现。解决哈希冲突的策略主要有：

​	•	**链表法（链式哈希）**：Go 内部会使用链表来存储哈希冲突的键值对。当两个键值对哈希值相同时，它们会被存储在同一个桶中，并通过链表链接。

​	•	**探测法**：Go 语言在某些情况下也会使用开放定址法（即在冲突时使用线性探测）。

Go 的 map 实现中还考虑了负载因子的动态调整和哈希表的扩展，因此它能够有效地处理哈希冲突，并根据实际需要调整性能。



**总结：**

​	•	**Redis**：采用链式哈希和再哈希机制，结合开放定址法优化冲突。

​	•	**C++**：通过链式哈希和开放定址法来解决冲突，标准库提供了内置的哈希表实现。

​	•	**Golang**：内部使用链式哈希法，也有一定的开放定址处理，结合负载因子优化性能。





# 布隆过滤器

## Redis布隆过滤器

1. 安装

```bash
git clone https://github.com/RedisBloom/RedisBloom.git
cd RedisBloom
make

# 启动Redis并加载RedisBloom模块
redis-server --loadmodule ./redisBloom.so
```

2. 操作

```bash
#置了期望的误差率为0.01，并且预计存储1000个元素。
127.0.0.1:6379> BF.RESERVE my_filter 0.01 1000
OK 

#添加
127.0.0.1:6379> BF.ADD my_filter "element1"
(integer) 1
127.0.0.1:6379> BF.ADD my_filter "element2"
(integer) 1

#查找
127.0.0.1:6379> BF.EXISTS my_filter "element1"
(integer) 1
127.0.0.1:6379> BF.EXISTS my_filter "element3"
(integer) 0
```

### 误差率（假阳率）

布隆过滤器的核心特点是：允许**假阳性**（即报告某个元素在集合中，但实际上它不在集合中），但绝不允许**假阴性**（即报告某个元素不在集合中，但实际上它在集合中）。

•	**低误差率（假阳性率）**意味着布隆过滤器需要更多的空间来存储信息（更多的位、更多的哈希函数），但查询时可以获得更准确的结果（更少的假阳性）。

•	**高误差率（假阳性率）**可以减少布隆过滤器所需的空间，使得内存使用更高效，但可能会导致查询时返回更多的假阳性，降低准确性。

## C++实现布隆过滤器
