# 项目介绍

干什么？怎么做？效果？

实习部门维护老项目UF2.0证券交易系统，需要完成补丁单，对应多个需求单，对应多个任务单，关系复杂切时间管理较为困难，导致管理员和员工查看空闲时间较困难，这个项目通过公司效能平台导出xml文件，再导入补丁到项目中（补丁对应多个需求，需求对应多个任务单），对于员工来说只需要关系任务单，并且可以修改任务单信息，比如说截止日期，相关修改会通过redis的发布订阅模式通知其他相关用户，对于管理员来说能够清晰的看到在一个时间线上每个员工每天的工作压力以及空闲时间。

其他功能：使用fyne编写客户端，定时发送邮件、docker部署、nginx负载均衡

# 相关问题

## gRPC与HTTP的区别

1️⃣**协议层次和数据格式**：

- **HTTP**：HTTP是一种应用层协议，通常用于Web服务，通过请求和响应传输数据。常见的数据格式是JSON或XML，易于人类读取和调试。
- **gRPC**：gRPC基于HTTP/2协议，使用Protobuf（Protocol Buffers）作为数据序列化格式。Protobuf是一种二进制格式，比JSON更紧凑、更高效，尤其在传输大规模数据时优势明显。

2️⃣ **性能和效率**：

- **HTTP**：由于使用了文本格式（如JSON），HTTP请求和响应的数据量相对较大，解析速度相对较慢。
- **gRPC**：gRPC利用了HTTP/2的多路复用、流控制、头部压缩等特性，结合Protobuf的高效数据编码，在网络和处理性能上都有明显优势。

**3️⃣ 流式通信**：

- **HTTP**：标准的HTTP是基于请求-响应的模型，不支持双向流通信。WebSocket可以实现实时双向通信，但不是HTTP本身的特性。
- **gRPC**：gRPC原生支持双向流式通信（双向流、服务器流、客户端流），适合需要实时数据交换的场景。

4️⃣ **类型安全**：

- **HTTP**：使用JSON时，由于没有严格的类型定义，容易在服务端和客户端之间产生类型不匹配的错误。
- **gRPC**：gRPC使用Protobuf定义服务和消息的结构，提供了强类型的接口，编译时即能发现数据结构不匹配的问题。

5️⃣ **生态系统和兼容性**：

- **HTTP**：作为Web应用的基础协议，HTTP有着广泛的生态系统支持和兼容性。几乎所有编程语言和平台都支持HTTP。
- **gRPC**：gRPC提供了跨语言支持，但在一些特定场景下（如浏览器端）不如HTTP普遍。此外，gRPC对客户端和服务端都需要依赖Protobuf定义文件，这可能增加复杂性。

### gRPC geteway

当客户端不支持 gRPC 协议时，或者需要将 gRPC 服务暴露给 Web 应用程序时，需要一种将 RESTful API 转换为 gRPC 的方式

**gRPC-Gateway 实现**

gRPC-Gateway 是一个能够 **将 gRPC 服务转换为 RESTful API** 的工具，允许 HTTP/JSON 请求被转换成 gRPC 请求，并返回 gRPC 响应给 HTTP 客户端。这样可以让 gRPC 服务兼容 REST 生态。

- go-zero gRPC gateway：https://go-zero.dev/docs/tutorials/gateway/grpc



### protubuf介绍、用途、与json的区别

**1️⃣ Protocol Buffers（protobuf）介绍**

Protocol Buffers（简称 **protobuf**）是 Google 开发的一种**跨语言、跨平台的序列化协议**，用于结构化数据的序列化（类似于 XML 或 JSON，但更加高效）。protobuf 使用 .proto 文件定义数据结构，并通过编译器 protoc 生成代码，支持多种编程语言（如 C++, Go, Java, Python 等）。

**2️⃣ protobuf 的用途**

protobuf 主要用于高效的数据交换和存储，常见用途包括：

​	•	**远程过程调用（RPC）**：如 gRPC 框架用于服务间通信，protobuf 作为数据格式。

​	•	**数据存储和配置**：可用于持久化存储结构化数据，如数据库存储或配置文件。

​	•	**跨语言数据交换**：不同语言间的数据传输格式，如 Go 与 C++ 之间的数据传输。

​	•	**移动端与后端通信**：Android、iOS 与服务器之间的数据同步。

**3️⃣ protobuf 与 JSON 的区别**

| **比较项**   | **protobuf**                         | **JSON**                       |
| ------------ | ------------------------------------ | ------------------------------ |
| **数据格式** | 二进制格式，紧凑高效                 | 文本格式，可读性好但冗余大     |
| **体积大小** | 体积小，适合带宽受限的场景           | 体积大，占用更多存储和传输带宽 |
| **解析速度** | 解析速度快（基于二进制结构）         | 解析速度较慢（基于文本解析）   |
|              |                                      |                                |
| **自描述性** | 依赖 .proto 文件，不包含字段名称     | 自带字段名称，易读但冗余       |
| **扩展性**   | 向后兼容，新增字段不会影响旧版本解析 | 也支持扩展性，但解析性能受限   |
| **使用场景** | 高性能 RPC、嵌入式、移动端等         | 配置文件、Web API、日志存储等  |

📌 **总结**：

如果**追求高效传输**（如 gRPC、移动端、服务器间通信），protobuf 是更好的选择。

如果**强调可读性和灵活性**（如前后端 JSON API），JSON 可能更适合。

## 什么是GORM，有什么用，与直接使用MySQL库的区别

让我解释一下 GORM (Go Object Relational Mapping):

**1️⃣ GORM 是什么**

GORM 是 Go 语言的 ORM (对象关系映射) 库，它将数据库表和 Go 结构体对应起来，简化数据库操作。并且支持自动迁移、钩子、事务等功能，让写代码更加简洁高效

**2️⃣ GORM vs 原生 MySQL 对比**

**原生 MySQL：**

```go
// 使用原生 MySQL 
db, err := sql.Open("mysql", "user:password@/dbname")

// 查询用户
rows, err := db.Query("SELECT id, name, email FROM users WHERE id = ?", 1)
var user struct {
    ID    int
    Name  string
    Email string
}
for rows.Next() {
    err := rows.Scan(&user.ID, &user.Name, &user.Email)
}
```

**使用 GORM：**
```go
// 使用 GORM
db, err := gorm.Open(mysql.Open("user:password@/dbname"))

// 定义模型
type User struct {
    ID    uint
    Name  string
    Email string
}

// 查询用户
var user User
db.First(&user, 1) // 查询 id 为 1 的用户
```

**3️⃣ GORM 主要特性**

1. **自动迁移**：
```go
// 自动创建或更新表结构
db.AutoMigrate(&User{}, &Product{})
```

2. **关联关系**：
```go
type User struct {
    ID       uint
    Name     string
    Orders   []Order  // 一对多关系
    Profile  Profile  // 一对一关系
}

// 查询包含关联数据
db.Preload("Orders").First(&user)
```

3. **钩子方法**：
```go
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // 创建记录前的操作
    u.CreatedAt = time.Now()
    return nil
}
```

4. **事务处理**：
```go
db.Transaction(func(tx *gorm.DB) error {
    // 在事务中执行操作
    if err := tx.Create(&user).Error; err != nil {
        return err
    }
    return nil
})
```

**4️⃣ GORM 的优势**

1. **代码更简洁**：
```go
// GORM 的链式操作
db.Where("name = ?", "张三").
   Where("age > ?", 20).
   Find(&users)

// 原生 SQL
rows, err := db.Query(`
    SELECT * FROM users 
    WHERE name = ? AND age > ?
`, "张三", 20)
```

2. **类型安全**：
```go
type TaskInfo struct {
    TaskID     string    `gorm:"column:task_id;primaryKey"`
    Deadline   time.Time `gorm:"column:deadline"`
    Principal  string    `gorm:"column:principal"`
}

// GORM 会自动处理类型转换
var task TaskInfo
db.First(&task)
```

3. **功能丰富**：
```go
// 软删除
type User struct {
    gorm.Model  // 包含 DeletedAt 字段
    Name string
}

// 分页查询
db.Limit(10).Offset(0).Find(&users)

// 复杂查询
db.Model(&User{}).
   Select("name, sum(age) as total_age").
   Group("name").
   Having("sum(age) > ?", 100).
   Find(&results)
```

5️⃣ **实际应用场景**

从项目代码中可以看到：
```go:models/models.go
type TaskInfo struct {
    TaskID             string    `gorm:"column:task_id;type:varchar(25);primaryKey;not null;comment:任务单号"`
    Comment            string    `gorm:"column:comment;type:varchar(1000);comment:任务描述"`
    EmergencyLevel     int       `gorm:"column:emergency_level;default:0;comment:紧急程度"`
    Deadline           time.Time `gorm:"column:deadline;type:date;default:(date_format((now() + interval 3 day),_utf8mb4'%Y-%m-%d'));comment:截止日期"`
    Principal          string    `gorm:"column:principal;type:varchar(20);not null;comment:负责人"`
}
```

这种方式比直接写 SQL 更容易维护和理解，同时通过 tag 可以详细定义字段属性。

6️⃣ **使用建议**

1. 简单查询用 GORM
2. 复杂查询可以混用原生 SQL
3. 利用 GORM 的模型定义和验证功能
4. 合理使用预加载避免 N+1 查询问题

GORM 让数据库操作更加面向对象，提高了开发效率，但也需要注意性能开销。在选择使用时要根据实际需求权衡。

## 发布订阅模式实现

- 没有考虑持久性、可靠性

当有客户端建立连接时，服务端建立stream流用于服务端推送，订阅redis的“update”频道，获取发布channel，之后循环获取发布channel的消息，当客户端调用某一个更改任务的rpc后，会向update频道发送消息，该消息回发布给所有订阅update频道的通道中，服务端channel收到之后对消息进行分发处理，判断是否将该消息通过stream发送给本次链接的客户端

### 离线消息处理

通过redis中的list存放离线用户的消息

```go
// Subscribe 多个客户端调用
func (ns *notificationServer) Subscribe(req *pb.SubscriptionRequest, stream pb.NotificationService_SubscribeServer) error {
	
  //...

	for msg := range ch {
		//...

		if from == req.ClientId {
			if _, ok := ns.clients[to]; !ok {
				ns.storeMessage(to, msg.Payload)
			}
			continue
		}
		//...
	}
  
  //...

}


// 消息持久化存储
func (ns *notificationServer) storeMessage(clientId, message string) {
	key := fmt.Sprintf("user:%s:messages", clientId)
	ns.rdb.RPush(ns.ctx, key, message)
	ns.rdb.Expire(ns.ctx, fmt.Sprintf(key, clientId), time.Hour*24)
}
```



### redis实现消息队列的方式

- [rabbitMQ](../RabbitMQ.md)

**1️⃣ list实现**

LPUSH + BRPOP 实现

> - 单消费者
> - 无法保证可靠性

2️⃣**发布订阅实现**

![image-20240921203124380](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921203124380.png)

> 不支持数据持久化
>
> 无法保证可靠性
>
> 消息堆积有上限，超出时数据丢失（消费者无法接收到离线时的数据）

**3️⃣[Streams](https://redis.io/docs/latest/commands/?group=stream)**

**支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠**

1. `XADD`生产

![image-20240921204204306](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921204204306.png)

2. `XREAD`消费

通过`XREAD`的`$`读取，可能会出现==消息漏读==的问题，因为`$`只会读取最新消息

![image-20240921204701258](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921204701258.png)

3. `XGROUP`消费者组

![image-20240921205309401](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921205309401.png)

- `XGROUP CREATE`
- `XREADGROUP`



### 为什么要用redis的发布订阅模式而不直接使用grpc的stream

- 降低了服务器内存压力
- 更方便的实现广播消息
- 分布式场景下可以接受多个服务端节点的消息



### 为什么选择redis的发布订阅模式作为消息队列？

- 简单，轻便，没有消息持久化和可靠性的需求，刚好能满足项目需求，没必要引入“重量”的消息队列，从而增加代码和整个架构的复杂程度
- 对离线用户消息做了持久化



## 定时发送怎么做的

```go
package main

import (
    "github.com/robfig/cron/v3"
    "log"
)

func main() {
    // 创建定时任务管理器
    c := cron.New()

    // 添加定时任务
    c.AddFunc("0 9 * * *", func() {
        log.Println("执行 9 点的任务")
        queryAndSendEmail()
    })

    c.AddFunc("0 13 * * *", func() {
        log.Println("执行 13 点的任务")
        queryAndSendEmail()
    })

    // 启动定时任务
    c.Start()

    // 保持程序运行
    select {}
}


```







