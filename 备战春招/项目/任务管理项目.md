# 项目介绍

干什么？怎么做？效果？

首先项目背景是公司的补丁、需求与任务单繁琐，导致管理员和员工查看空闲时间较困难，这个项目通过公司效能平台导出xml文件，再导入补丁到项目中（补丁对应多个需求，需求对应多个任务单），对于员工来说只需要关系任务单，并且可以修改任务单信息，比如说截止日期，相关修改回通过redis的发布订阅模式通知其他相关用户，对于管理员来说能够清晰的看到在一个时间线上每个员工每天的工作压力以及空闲时间。

# 相关问题

## gRPC与HTTP的区别

1️⃣**协议层次和数据格式**：

- **HTTP**：HTTP是一种应用层协议，通常用于Web服务，通过请求和响应传输数据。常见的数据格式是JSON或XML，易于人类读取和调试。
- **gRPC**：gRPC基于HTTP/2协议，使用Protobuf（Protocol Buffers）作为数据序列化格式。Protobuf是一种二进制格式，比JSON更紧凑、更高效，尤其在传输大规模数据时优势明显。

2️⃣ **性能和效率**：

- **HTTP**：由于使用了文本格式（如JSON），HTTP请求和响应的数据量相对较大，解析速度相对较慢。
- **gRPC**：gRPC利用了HTTP/2的多路复用、流控制、头部压缩等特性，结合Protobuf的高效数据编码，在网络和处理性能上都有明显优势。

**3️⃣ 流式通信**：

- **HTTP**：标准的HTTP是基于请求-响应的模型，不支持双向流通信。WebSocket可以实现实时双向通信，但不是HTTP本身的特性。
- **gRPC**：gRPC原生支持双向流式通信（双向流、服务器流、客户端流），适合需要实时数据交换的场景。

4️⃣ **类型安全**：

- **HTTP**：使用JSON时，由于没有严格的类型定义，容易在服务端和客户端之间产生类型不匹配的错误。
- **gRPC**：gRPC使用Protobuf定义服务和消息的结构，提供了强类型的接口，编译时即能发现数据结构不匹配的问题。

5️⃣ **生态系统和兼容性**：

- **HTTP**：作为Web应用的基础协议，HTTP有着广泛的生态系统支持和兼容性。几乎所有编程语言和平台都支持HTTP。
- **gRPC**：gRPC提供了跨语言支持，但在一些特定场景下（如浏览器端）不如HTTP普遍。此外，gRPC对客户端和服务端都需要依赖Protobuf定义文件，这可能增加复杂性。

## 什么是GORM，有什么用，与直接使用MySQL库的区别

让我解释一下 GORM (Go Object Relational Mapping):

**1️⃣ GORM 是什么**

GORM 是 Go 语言的 ORM (对象关系映射) 库，它将数据库表和 Go 结构体对应起来，简化数据库操作。并且支持自动迁移、钩子、事务等功能，让写代码更加简洁高效

**2️⃣ GORM vs 原生 MySQL 对比**

**原生 MySQL：**

```go
// 使用原生 MySQL 
db, err := sql.Open("mysql", "user:password@/dbname")

// 查询用户
rows, err := db.Query("SELECT id, name, email FROM users WHERE id = ?", 1)
var user struct {
    ID    int
    Name  string
    Email string
}
for rows.Next() {
    err := rows.Scan(&user.ID, &user.Name, &user.Email)
}
```

**使用 GORM：**
```go
// 使用 GORM
db, err := gorm.Open(mysql.Open("user:password@/dbname"))

// 定义模型
type User struct {
    ID    uint
    Name  string
    Email string
}

// 查询用户
var user User
db.First(&user, 1) // 查询 id 为 1 的用户
```

**3️⃣ GORM 主要特性**

1. **自动迁移**：
```go
// 自动创建或更新表结构
db.AutoMigrate(&User{}, &Product{})
```

2. **关联关系**：
```go
type User struct {
    ID       uint
    Name     string
    Orders   []Order  // 一对多关系
    Profile  Profile  // 一对一关系
}

// 查询包含关联数据
db.Preload("Orders").First(&user)
```

3. **钩子方法**：
```go
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // 创建记录前的操作
    u.CreatedAt = time.Now()
    return nil
}
```

4. **事务处理**：
```go
db.Transaction(func(tx *gorm.DB) error {
    // 在事务中执行操作
    if err := tx.Create(&user).Error; err != nil {
        return err
    }
    return nil
})
```

**4️⃣ GORM 的优势**

1. **代码更简洁**：
```go
// GORM 的链式操作
db.Where("name = ?", "张三").
   Where("age > ?", 20).
   Find(&users)

// 原生 SQL
rows, err := db.Query(`
    SELECT * FROM users 
    WHERE name = ? AND age > ?
`, "张三", 20)
```

2. **类型安全**：
```go
type TaskInfo struct {
    TaskID     string    `gorm:"column:task_id;primaryKey"`
    Deadline   time.Time `gorm:"column:deadline"`
    Principal  string    `gorm:"column:principal"`
}

// GORM 会自动处理类型转换
var task TaskInfo
db.First(&task)
```

3. **功能丰富**：
```go
// 软删除
type User struct {
    gorm.Model  // 包含 DeletedAt 字段
    Name string
}

// 分页查询
db.Limit(10).Offset(0).Find(&users)

// 复杂查询
db.Model(&User{}).
   Select("name, sum(age) as total_age").
   Group("name").
   Having("sum(age) > ?", 100).
   Find(&results)
```

5️⃣ **实际应用场景**

从项目代码中可以看到：
```go:models/models.go
type TaskInfo struct {
    TaskID             string    `gorm:"column:task_id;type:varchar(25);primaryKey;not null;comment:任务单号"`
    Comment            string    `gorm:"column:comment;type:varchar(1000);comment:任务描述"`
    EmergencyLevel     int       `gorm:"column:emergency_level;default:0;comment:紧急程度"`
    Deadline           time.Time `gorm:"column:deadline;type:date;default:(date_format((now() + interval 3 day),_utf8mb4'%Y-%m-%d'));comment:截止日期"`
    Principal          string    `gorm:"column:principal;type:varchar(20);not null;comment:负责人"`
}
```

这种方式比直接写 SQL 更容易维护和理解，同时通过 tag 可以详细定义字段属性。

6️⃣ **使用建议**

1. 简单查询用 GORM
2. 复杂查询可以混用原生 SQL
3. 利用 GORM 的模型定义和验证功能
4. 合理使用预加载避免 N+1 查询问题

GORM 让数据库操作更加面向对象，提高了开发效率，但也需要注意性能开销。在选择使用时要根据实际需求权衡。

## 发布订阅模式实现

当有客户端建立连接时，服务端建立stream流用于服务端推送，订阅redis的“update”频道，获取发布channel，之后循环获取发布channel的消息，当客户端调用某一个更改任务的rpc后，会向update频道发送消息，该消息回发布给所有订阅update频道的通道中，服务端channel收到之后对消息进行分发处理，判断是否将该消息通过stream发送给本次链接的客户端

### 持久化怎么做

通过redis中的list存放离线用户的消息

```go
// Subscribe 多个客户端调用
func (ns *notificationServer) Subscribe(req *pb.SubscriptionRequest, stream pb.NotificationService_SubscribeServer) error {
	
  //...

	for msg := range ch {
		//...

		if from == req.ClientId {
			if _, ok := ns.clients[to]; !ok {
				ns.storeMessage(to, msg.Payload)
			}
			continue
		}
		//...
	}
  
  //...

}


// 消息持久化存储
func (ns *notificationServer) storeMessage(clientId, message string) {
	key := fmt.Sprintf("user:%s:messages", clientId)
	ns.rdb.RPush(ns.ctx, key, message)
	ns.rdb.Expire(ns.ctx, fmt.Sprintf(key, clientId), time.Hour*24)
}
```



### redis实现消息队列的方式

- [rabbitMQ](../RabbitMQ.md)

**1️⃣ list实现**

LPUSH + BRPOP 实现

> - 单消费者
> - 无法保证可靠性

2️⃣**发布订阅实现**

![image-20240921203124380](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921203124380.png)

> 不支持数据持久化
>
> 无法保证可靠性
>
> 消息堆积有上限，超出时数据丢失（消费者无法接收到离线时的数据）

**3️⃣[Streams](https://redis.io/docs/latest/commands/?group=stream)**

1. `XADD`生产

![image-20240921204204306](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921204204306.png)

2. `XREAD`消费

通过`XREAD`的`$`读取，可能会出现==消息漏读==的问题，因为`$`只会读取最新消息

![image-20240921204701258](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921204701258.png)

3. `XGROUP`消费者组

![image-20240921205309401](https://typora-dusong.oss-cn-chengdu.aliyuncs.com/image-20240921205309401.png)

- `XGROUP CREATE`
- `XREADGROUP`



### 为什么要用redis的发布订阅模式而不直接使用grpc的stream

- 降低了服务器内存压力
- 更方便的实现广播消息
- 分布式场景下可以接受多个服务端节点的消息





## 定时发送怎么做的

```go
package main

import (
    "github.com/robfig/cron/v3"
    "log"
)

func main() {
    // 创建定时任务管理器
    c := cron.New()

    // 添加定时任务
    c.AddFunc("0 9 * * *", func() {
        log.Println("执行 9 点的任务")
        queryAndSendEmail()
    })

    c.AddFunc("0 13 * * *", func() {
        log.Println("执行 13 点的任务")
        queryAndSendEmail()
    })

    // 启动定时任务
    c.Start()

    // 保持程序运行
    select {}
}


```







